直接插入 
把待排序的纪录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的纪录插入完为止，得到一个新的有序序列
稳定  |  时间：O(n^2)  |  空间：O(1)
设无序数组为a[0…n-1]。
    1.初始时，a[0]自成1个有序区，无序区为a[1..n-1]。
    2.令i=1,将a[i]插入当前的有序区a[0…i-1]中形成a[0…i]的有序区间。
    3.i++并重复第二步直到i==n-1，排序完成。
//直接插入排序
void insertSort(int*arr,int n){
    //第一个数肯定是有序的，从第二个数开始遍历
    for(int i =1; i < n;++i){
        int temp = arr[i];
        int j;
        for(j = i -1; j >=0&& temp < arr[j];--j){
            arr[j +1]= arr[j];
        }
        arr[j +1]= temp;
    }
}
function insertSort($arr){
    for($i=1, $len=count($arr); $i<$len; $i++){
        $tmp = $arr[$i];
        for($j=$i-1;$j>=0;$j--){
            if($tmp < $arr[$j]){
                $arr[$j+1]= $arr[$j];
                $arr[$j]= $tmp;
            }else{
                break;
            }
        }
    }
    return $arr;
}
 
 
冒泡排序
两两比较待排序记录的关键字，发现两个记录的次序相反时即进行交换，直到没有反序的记录为止。按照从小到大或者从大到小的顺序进行交换,这样一趟过去后,最大或最小的数字被交换到了最后一位。
时间 平均：O(n^2)
最好情况：数组已有序O(n)；
最坏情况: 数组反序O(n^2)
空间复杂度
原地排序，空间复杂度为O(1)。
稳定
设数组a[0..n-1]长度为n,
    1．比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个数据交换。
    2．这样对数组的第0个数据到n-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第n-1个位置。
    3．n=n-1，如果n不为0就重复前面二步，否则排序完成。
BUBBLE_SORT(A){
    for i = length[A] to 2{
        for j =1 to i-1{
            if A[j]> A[j+1]{
                exchange A[j] and A[j+1];
            }
        }
    }
}
 
直接选择
无序数组a[0...n-1]，第一次从a[0]~a[n-1]中选取最小值，与a[0]交换，
第二次从a[1]~a[n-1]中选取最小值，与a[1]交换，....，
第i次从a[i-1]~a[n-1]中选取最小值，与a[i-1]交换，.....，
第n-1次从a[n-2]~a[n-1]中选取最小值，与a[n-2]交换，
总共通过n-1次，得到一个按关键字从小到大排列的有序序列
共进行n-1次选择和交换，每次选择需要进行 n-i 次比较 (1<=i<=n-1),而每次交换最多需要3次移动，总的比较次数C=(n*n - n)/2
时间复杂度O(n^2)。
原地排序，空间复杂度O(1)。
直接选择排序不是稳定的排序算法。
//直接排序
SELECTION_SORT(A){
    for i=1 to n-1
        min=i
        for j=i+1 to n
            if A[min]> A[j]
                min = j
                swap A[min]<-> A[i]
}
 
希尔排序
把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。
时间复杂度与增量序列的选取有关
希尔增量时间复杂度为O(n²)，而Hibbard增量的希尔排序的时间复杂度为O(n^(3/2))，希尔排序时间复杂度的下界是n*log2n，希尔排序时间复杂度O(Nlog2N)，
空间复杂度O(1)。不稳定排序算法
希尔排序算法过程：
先取一个正整数gap
例如数组a[49, 38, 65, 97, 26, 13, 27, 49, 55, 4]
第1次 步长 gap = 10 / 2 = 5，分成了五组(49, 13) (38, 27) (65, 49) (97, 55) (26, 4)，
每组排序后变成了(13, 49) (27, 38) (49, 65) (55, 97) (4, 26)。
第1次排序结果：13 27 49 55 4 49 38 65 97 26
第2次 步长 gap = 5 / 2 = 2，分成了2组(13,49,4,38,97) (27,55,49,65,26)
每组排序后变成了(4,13,38,49,97) (26,27,49,55,65)
第2次排序结果：4 26 13 27 38 49 49 55 97 65
第3次 步长 gap = 2 / 2 = 1
分为一组，直接插入排序后，数组有序。
voidShellInsert(int* pDataArray,int d,int iDataNum){
    for(int i = d; i < iDataNum; i +=1)//从第2个数据开始插入
    {
        int j = i - d;
        int temp = pDataArray[i];//记录要插入的数据
        while(j >=0&& pDataArray[j]> temp)//从后向前，找到比其小的数的位置
        {
            pDataArray[j+d]= pDataArray[j];//向后挪动
            j -= d;
        }
     
        if(j != i - d)//存在比其小的数
            pDataArray[j+d]= temp;
    }
}

voidShellSort(int* pDataArray,int iDataNum)
{
    int d = iDataNum /2;//初始增量设为数组长度的一半。iDataNum为无序数据个数
    while(d >=1)
    {
        ShellInsert(pDataArray, d, iDataNum); 
        d = d /2;//每次增量变为上次的二分之一
    }
}
 
 
归并排序
将已有序的子序列合并，得到完全有序的序列；设两个有序的子序列放在同一向量中相邻的位置上：a[low..m]，a[m+1..high]，先将它们合并到一个局部的暂存向量 a1中，待合并完成后将 a1 复制回 a[low..high]中。
时间复杂度为O(nlogn) 是归并排序算法中最好、最坏和平均的时间性能。
空间复杂度O(n)。
归并排序比较占用内存，但却是一种效率高且稳定的排序算法算法。
比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；
否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，
如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。
归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。
function mergeArray($arrA, $arrB){
    $a_i = $b_i =0;//设置两个起始位置标记
    $a_len = count($arrA);
    $b_len = count($arrB);
    while($a_i<$a_len && $b_i<$b_len){
        //当数组A和数组B都没有越界时
        if($arrA[$a_i]< $arrB[$b_i]){
            $arrC[]= $arrA[$a_i++];
        }else{
            $arrC[]= $arrB[$b_i++];
        }
    }
    //判断 数组A内的元素是否都用完了，没有的话将其全部插入到C数组内：
    while($a_i < $a_len){
        $arrC[]= $arrA[$a_i++];
    }
    //判断 数组B内的元素是否都用完了，没有的话将其全部插入到C数组内：
    while($b_i < $b_len){
        $arrC[]= $arrB[$b_i++];
    }
    return $arrC;
}
 
快速排序
当前待排序的无序区为 a[low..high]，在 a[low..high]中任选一个记录作为基准(pivot)，以此基准将当前无序区划分为左、右两个较小的子区间 a[low..pivot-1]和 a[pivot+1..high]，并使左边子区间中所有记录的关键字均小于等于基准记录(不妨记为 pivot)的关键字 pivot.key，右边的子区间中所有记录的关键字均大于等于 pivot.key，而基准记录 pivot 则位于正确的位置(pivot)上，它无须参加后续的排序。通过递归调用快速排序对左、右子区间 a[low..pivot-1]和R[pivot+1..high]快速排序。
快速排序算法平均时间复杂度O(nlgn)，最坏O(n^2)。快速排序需要栈空间来实现递归，如果数组按局等方式被分割时，则最大的递归深度为 log n，需要的栈空间为 O(log n)。最坏的情况下在递归的每一级上，数组分割成长度为0的左子数组和长度为 n - 1 的右数组。这种情况下，递归的深度就成为 n，需要的栈空间为 O(n)。快速排序不是稳定排序算法。
一趟快速排序的过程：
1.设置两个变量i、j，排序开始的时候：i=0，j=N-1；
2.以第一个数组元素作为关键数据，赋值给key，即key=A[0]；
3.从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；
4.从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；
5.重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。
query
function quick_sort($arr){
    $length = count($arr);
    //如果没有返回，说明数组内的元素个数 多余1个，需要排序
    if($length <=1){
        return $arr;
    }
    $pivot = $arr[0];//选择第一个元素
    //遍历 除了标尺外的所有元素，按照大小关系放入两个数组内
    $left_array = array();//小于标尺的
    $right_array = array();//大于标尺的
    for($i=1; $i<$length; $i++){
        if($pivot > $arr[$i]){
            $left_array[]= $arr[$i];//放入左边数组
        }else{
            $right_array[]= $arr[$i];//放入右边
        }
    }
    //再分别对 左边 和 右边的数组进行相同的排序处理方式
    //递归调用这个函数,并记录结果
    $left_array = quick_sort($left_array);
    $right_array = quick_sort($right_array);
    return array_merge($left_array, array($pivot), $right_array);
}
$arr = array(4,5,6,7,8,9,0,1,2,3);
 
$arr2 = quick_sort($arr)
 
 
堆排序
思想：n个关键字序列Kl，K2，…，Kn称为（Heap），当且仅当该序列满足如下性质（简称为堆性质）：
    (1)ki<=k(2i）且ki<=k(2i+1)(1≤i≤ n/2），当然，这是小根堆，大根堆则换成>=号。k(i)相当于二叉树的非叶子结点， K(2i)则是左子节点，k(2i+1)是右子节点，若将此序列所存储的向量a[1..n]看做是一棵完全二叉树的存储结构，则堆实质上是满足如下性质的完全二叉树：树中任一非叶子结点的关键字均不大于（或不小于）其左右孩子（若存在）结点的关键字。大根堆和小根堆：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最小者的堆称为小根堆，又称最小堆。根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最大者，称为大根堆，又称最大堆。注意：①堆中任一子树亦是堆。②以上讨论的堆实际上是二叉堆（Binary Heap)。
堆排序过程的时间复杂度是O(nlogn)。因为建堆的时间复杂度是O(n)（调用一次）；调整堆的时间复杂度是logn，调用了n-1次，所以堆排序的时间复杂度是O(nlogn)。
堆排序时间复杂度O(n*logn)。空间复杂度O(1)。堆排序不是稳定排序算法。
用大根堆排序的基本思想：
    1.先将初始文件a[1..n]建成一个大根堆，此堆为初始的无序区。
    2.再将关键字最大的记录a[1]（即堆顶）和无序区的最后一个记录a[n]交换，由此得到新的无序区a[1..n-1]和有序区a[n]，且满足a[1..n-1].keys≤a[n].key。
    3.由于交换后新的根a[1]可能违反堆性质，故应将当前无序区a[1..n-1]调整为堆。然后再次将a[1..n-1]中关键字最大的记录a[1]和该区间的最后一个记录a[n-1]交换，由此得到新的无序区a[1..n-2]和有序区a[n-1..n]，且仍满足关系a[1..n-2].keys≤a[n-1..n].keys，同样要将a[1..n-2]调整为堆。
    直到无序区只有一个元素为止。
 
大根堆排序算法的基本操作：
    1.建堆，建堆是不断调整堆的过程，从len/2处开始调整，一直到第一个节点，此处len是堆中元素的个数。建堆的过程是线性的过程，从len/2到0处一直调用调整堆的过程，相当于o(h1)+o(h2)…+o(hlen/2) 其中h表示节点的深度，len/2表示节点的个数，这是一个求和的过程，结果是线性的O(n)。
    2.调整堆：调整堆在构建堆的过程中会用到，而且在堆排序过程中也会用到。利用的思想是比较节点i和它的孩子节点left(i),right(i)，选出三者最大(或者最小)者，如果最大（小）值不是节点i而是它的一个孩子节点，那边交换节点i和该节点，然后再调用调整堆过程，这是一个递归的过程。调整堆的过程时间复杂度与堆的深度有关系，是logn的操作，因为是沿着深度方向进行调整的。
    3.堆排序：堆排序是利用上面的两个过程来进行的。首先是根据元素构建堆。然后将堆的根节点取出(一般是与最后一个节点进行交换)，将前面len-1个节点继续进行堆调整的过程，然后再将根节点取出，这样一直到所有节点都取出。
<?php
#堆排序
function heapSort(&$arr){
    #初始化大顶堆
    initHeap($arr,0, count($arr)-1);
     
    #开始交换首尾节点,并每次减少一个末尾节点再调整堆,直到剩下一个元素
    for($end = count($arr)-1; $end >0; $end--){
        $temp = $arr[0];
        $arr[0]= $arr[$end];
        $arr[$end]= $temp;
        ajustNodes($arr,0, $end -1);
        }
    }
     
    #初始化最大堆,从最后一个非叶子节点开始,最后一个非叶子节点编号为 数组长度/2 向下取整
    function initHeap(&$arr){
        $len = count($arr);
        for($start = floor($len /2)-1; $start >=0; $start--){
        ajustNodes($arr, $start, $len -1);
    }
}
 
#调整节点
# $arr：待调整数组 $start：调整的父节点坐标$end：待调整数组结束节点坐标
function ajustNodes(&$arr, $start, $end){
$maxInx = $start;
$len = $end +1;#待调整部分长度
$leftChildInx =($start +1)*2-1;#左孩子坐标
$rightChildInx =($start +1)*2;#右孩子坐标
 
#如果待调整部分有左孩子
if($leftChildInx +1<= $len){
#获取最小节点坐标
if($arr[$maxInx]< $arr[$leftChildInx]){
$maxInx = $leftChildInx;
}
 
#如果待调整部分有右子节点
if($rightChildInx +1<= $len){
if($arr[$maxInx]< $arr[$rightChildInx]){
$maxInx = $rightChildInx;
}
}
}
 
#交换父节点和最大节点
if($start != $maxInx){
$temp = $arr[$start];
$arr[$start]= $arr[$maxInx];
$arr[$maxInx]= $temp;
 
#如果交换后的子节点还有子节点,继续调整
if(($maxInx +1)*2<= $len){
ajustNodes($arr, $maxInx, $end);
}
}
}
 
$arr = array(1,5,3,7,9,10,2,8);
heapSort($arr);
print_r($arr);
?>
 
桶排序
思想桶排序的思想是把[0，1)划分为n个大小相同的子区间，每一子区间是一个桶。
然后将n个记录分配到各个桶中。因为关键字序列是均匀分布在[0，1)上的，所以一般不会有很多个记录落入同一个桶中。
由于同一桶中的记录其关键字不尽相同，所以必须采用关键字比较的排序方法(通常用插入排序)对各个桶进行排序，然后依次将各非空桶中的记录连接(收集)起来即可。
最坏情况时间复杂度：当分布不均匀时，全部元素都分到一个桶中，则O(n^2);最好情况分到不同的桶时间复杂度O(n)；桶排序的平均时间复杂度是线性的，即 O(n)。 
例如要对大小为[1..1000]范围内的n个整数A[1..n]排序，可以把桶设为大小为10的范围
具体而言，设集合B[1]存储[1..10]的整数，集合B[2]存储(10..20]的整数，……集合B[i]存储((i-1)10, i10]的整数，i = 1,2,..100。总共有100个桶。
然后对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。 然后再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任何排序法都可以。
最后依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这样就得到所有数字排好序的一个序列了。
query
//桶排序
BUCKET_SORT(A)
n = length[A]
create buckets B[n]
for i=1 to n
insert A[i] to B[A[i]]
for i=0 to n-1
sort B[i] with INSERTION_SORT
concatenate B[]
 
基数排序
n个记录的关键字进行排序，每个关键字看成是一个d元组：ki=(ki1, ki2,..., kid)，其中c0 <=kij <=cr-1 ( 1 <=i <=n, 1 <=j <=d )。
排序时先按kid 的值，从小到大将记录分到r（称为基数）个盒子中，再依次收集；然后按kid-1的值再这样作。直至按ki1分配和收集序列为止，排序结束。
在关键字为数字时，r=10, 0 <=ci <=9， 1 <=i <=d；
在关键字为字母时 r=26, ’A’ <=ci <=’Z’, 1 <=i <=d。
r为基数，d为位数。则基数排序的时间复杂度为O(d(n+r))。
在基数排序过程中，对于任何位数上的基数进行“装桶”操作时，都需要n+r个临时空间。
在基数排序过程中，每次都是将当前位数上相同数值的元素统一“装桶”，并不需要交换位置。所以基数排序是稳定的算法
例子一组数：12、 104、 13、 7、 9
（1）按个位数排序是12、13、104、7、9
（2）再根据十位排序104、7、9、12、13
（3）再根据百位排序7、9、12、13、104
如果在某一位的数字相同，那么排序结果要根据上一轮的数组确定，举个例子来说：07和09在十分位都是0，但是上一轮排序的时候09是排在07后面的；同样举一个例子，12和13在十分位都是1，但是由于上一轮12是排在13前面，所以在十分位排序的时候，12也要排在13前面。
radixSort(A,d)//d为A中元素最多的位数
for i=1 to d
do use a stable sort to sort array A on digit i